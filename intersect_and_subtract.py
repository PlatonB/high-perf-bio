__version__ = 'V1.1'

print('''
Модуль пересечения и вычитания.

Автор: Платон Быкадоров (platon.work@gmail.com), 2019.
Версия: V1.1.
Лицензия: GNU General Public License version 3.
Поддержать проект: https://money.yandex.ru/to/41001832285976
Документация: https://github.com/PlatonB/high-perf-bio/blob/master/README.md

Обязательно!
Перед запуском программы нужно установить
MongoDB и PyMongo (см. README).

Каждая таблица, размещаемая в БД, должна
иметь шапку и быть GZIP-архивированной.

--------------------------------------------------

Пересечение:
Указанное поле *каждой* левой коллекции пересекается
с одноимённым полем *всех* правых коллекций.

Как работает настройка глубины пересечения?
*Остаются* только те значения поля левой коллекции,
для которых *есть совпадение* в соответствующем
поле, как минимум, того количества правых
коллекций, что задано параметром глубины.

--------------------------------------------------

Вычитание:
Из указанного поля *каждой* левой коллекции
вычитается одноимённое поле *всех* правых коллекций.

Как работает настройка глубины вычитания?
*Остаются* только те значения поля левой коллекции,
для которых *нет совпадения* в соответствующем
поле, как минимум, того количества правых
коллекций, что задано параметром глубины.

--------------------------------------------------

Больше глубина - меньше результатов.

--------------------------------------------------

Если настройки, запрашиваемые в рамках интерактивного
диалога, вам непонятны - пишите, пожалуйста, в Issues.
''')

print('\nИмпорт модулей программы...')

import sys

#Подавление формирования питоновского кэша с
#целью предотвращения искажения результатов.
sys.dont_write_bytecode = True

from backend.db_manager import create_database, reindex_collections
from pymongo import MongoClient
from bson.decimal128 import Decimal128
import copy, os

#Создание объекта клиента PyMongo.
#Вывод имён всех MongoDB-баз,
#имеющихся на данном компьютере.
#Имена пригодятся для определения,
#существует ли база или ещё нет.
client = MongoClient()
db_names = client.list_database_names()

db_choice = input(f'''\nВыберите базу данных или создайте новую
(игнорирование ввода ==> создать новую)
[{"|".join(db_names)}|<enter>]: ''')
if db_choice == '':
        db_name, coll_names, indexed = create_database(client, db_names)
elif db_choice not in db_names:
        print(f'{db_choice} - недопустимая опция')
        sys.exit()
else:
        db_name, coll_names, indexed = reindex_collections(client, db_choice)
        
if len(coll_names) == 1:
        print('''Для пересечения или вычитания
требуется не менее двух коллекций''')
        sys.exit()
        
trg_dir_path = input('\nПуть к папке для результатов: ')

print(f'''\nПроиндексированные поля коллекций и
соответствующие типы данных базы {db_name}:\n''', indexed)

if len(indexed) > 1:
        col_name = input(f'''\nИмя поля, по которому пересекаем или вычитаем
[{"|".join(indexed.keys())}]: ''')
        if col_name not in indexed:
                print(f'{col_name} - недопустимая опция')
                sys.exit()
else:
        col_name = list(indexed.keys())[0]
        
print(f'''\nИмена всех коллекций базы {db_name}:\n''', coll_names)

left_coll_names = input(f'''\nИмена "левых" коллекций {db_name}
(через запятую с пробелом)
(игнорирование ввода ==> все коллекции БД сделать "левыми")
[...|<enter>]: ''').split(', ')
if left_coll_names == ['']:
        left_coll_names = copy.deepcopy(coll_names)
left_coll_names.sort()

right_coll_names = input(f'''\nИмена "правых" коллекций {db_name}
(через запятую с пробелом)
(игнорирование ввода ==> все коллекции БД сделать "правыми")
[...|<enter>]: ''').split(', ')
if right_coll_names == ['']:
        right_coll_names = copy.deepcopy(coll_names)
right_coll_names.sort()
right_coll_names_quan = len(right_coll_names)
if len(set(right_coll_names) & set(left_coll_names)) > 0:
        right_coll_names_quan -= 1
        
action = input('''\nПересекать или вычитать?
[intersect(|i)|subtract(|s)]: ''')
if action in ['intersect', 'i']:
        action, sign = 'int', '&'
elif action in ['subtract', 's']:
        action, sign = 'sub', '-'
else:
        print(f'{action} - недопустимая опция')
        sys.exit()
        
if right_coll_names_quan > 1:
        depth = int(input(f'''\nГлубина
(см. описание этой опции выше)
[1<=x<={right_coll_names_quan}]: '''))
        if 1 > depth > right_coll_names_quan:
                print(f'{depth} - недопустимая опция')
                sys.exit()
else:
        depth = 1
        
#Создание объекта базы данных.
db_obj = client[db_name]

#Все дальнейшие действия будут производиться
#для каждой левой коллекции по-отдельности.
for left_coll_name in left_coll_names:
        
        #Конструируем имя конечного файла
        #и абсолютный путь к этому файлу.
        #Начинаться имя будет с действия,
        #выбранного исследователем.
        #Происхождение имени файла
        #от имени левой коллекции
        #будет указывать на то, что
        #все данные, попадающие в файл,
        #берутся исключительно из неё.
        #Правые коллекции пригождаются
        #только для фильтрации левых.
        trg_file_name = f'{action}_res_{".".join(left_coll_name.split(".")[:-1])}'
        trg_file_path = os.path.join(trg_dir_path, trg_file_name)
        
        #Предотвращение возможной попытки
        #объединения коллекции самой с собой.
        cur_right_coll_names = [right_coll_name for right_coll_name in right_coll_names if right_coll_name != left_coll_name]
        
        #Открытие конечного файла на запись.
        with open(trg_file_path, 'w') as trg_file_opened:
                
                #Из имён полей возрождаем шапку
                #таблицы, по данным которой ранее
                #была создана текущая коллекция.
                header_line = '\t'.join(list(db_obj[left_coll_name].find_one())[1:])
                
                #Подготавливаем и прописываем первый хэдер.
                #Им будет выражение, состоящее из имени
                #текущей левой коллекции, знака, представляющего
                #выбранное действие, и перечисленных
                #через запятую имён правых коллекций.
                trg_file_opened.write(f'##{left_coll_name} {sign} {", ".join(cur_right_coll_names)}\n')
                
                #Второй хэдер - выбранная исследователем
                #глубина пересечения/вычитания.
                #Понятие глубины раскрыто как в
                #приветственном принте, так и в
                #комментарии к идущему ниже коду
                #фильтрации объединённых коллекций.
                trg_file_opened.write(f'##depth = {depth}\n')
                
                #Третий хэдер - ранее восстановленная шапка.
                trg_file_opened.write(header_line + '\n')
                
                #Создание объекта левой коллекции.
                left_coll_obj = db_obj[left_coll_name]
                
                #Формирование инструкции левостороннего внешнего объединения.
                query = [{'$lookup': {'from': right_coll_name,
                                      'localField': col_name,
                                      'foreignField': col_name,
                                      'as': right_coll_name.replace('.', '_')}} for right_coll_name in cur_right_coll_names]
                
                print(f'\nОбъединение "левой" коллекции {left_coll_name} базы {db_name} с "правыми"')
                
                #В результате выполнения созданной
                #выше инструкции каждая левая коллекция
                #объединяется со всеми правыми.
                #Каждый документ, получающийся в
                #результате объединения, содержит:
                #1. все поля документа левой коллекции;
                #2. поля с соответствиями из правых
                #коллекций (далее - результирующие).
                #Если для элемента выбранного поля
                #данного левого документа не нашлось
                #совпадений в одной из правых коллекций,
                #то в результирующем поле появится
                #пустой список (Python-представление
                #Null-значения из мира баз данных).
                #Если же совпадение имеется, то в
                #качестве значения результирующего
                #поля возвратится список с содержимым
                #соответствующего правого документа.
                #Если выявилось совпадение с несколькими
                #документами какой-то одной правой
                #коллекции, то они в полном составе
                #поступят в результирующее поле.
                #Из всего описанного следует, что
                #фильтровать потом результаты
                #пересечения или вычитания можно
                #будет по количеству пустых или
                #непустых результирующих списков.
                #Теперь про повторы: в конечный
                #файл направятся все дубли элемента,
                #находящиеся в пределах поля левой
                #коллекции, но от повторов
                #правых элементов копийность
                #результатов не зависит.
                curs_obj = left_coll_obj.aggregate(query)
                
                print('Фильтрация документов')
                
                #Создаём флаг, по которому далее будет
                #определено, оказались ли в конечном
                #файле строки, отличные от хэдеров.
                empty_res = True
                
                #Правила фильтрации результатов
                #левостороннего объединения должны
                #были быть заданы исследователем.
                #Первый фильтр - само действие -
                #пересечение или вычитание.
                #Судьба левого документа будет
                #определяться непустыми результирующими
                #списками при пересечении и
                #пустыми в случае вычитания.
                #Второй фильтр - глубина: левый
                #документ получит приглашение
                #в конечный файл только, если
                #будет достигнут порог количества
                #непустых/пустых результирующих списков.
                for doc in curs_obj:
                        depth_meter = 0
                        for right_coll_name in cur_right_coll_names:
                                if right_coll_name == left_coll_name:
                                        continue
                                right_coll_alias = right_coll_name.replace('.', '_')
                                if (action == 'int' and doc[right_coll_alias] != []) or \
                                   (action == 'sub' and doc[right_coll_alias] == []):
                                        depth_meter += 1
                                if depth_meter == depth:
                                        row = [str(val) for val in list(doc.values())[1:] if type(val).__name__ != 'list']
                                        trg_file_opened.write('\t'.join(row) + '\n')
                                        empty_res = False
                                        break
                                
        #Если флаг-индикатор так и
        #остался равен True, значит,
        #результатов пересечения/вычитания
        #для данной левой коллекции нет, и в
        #конечный файл попали только хэдеры.
        #Такие конечные файлы программа удалит.
        if empty_res == True:
                os.remove(trg_file_path)
                
client.close()
